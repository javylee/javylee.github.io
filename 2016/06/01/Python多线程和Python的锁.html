<!DOCTYPE html><html><head><meta charset="utf-8"><title>Python多线程和Python的锁 | 技术成长的烦恼</title><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="description" content="title: Python多线程和Python的锁
tags: PythonPython中实现多线程有两种方式，一种基于_thread模块(在Python2.x版本中为thread模块，没有下划线)的start_new_thread()函数，另一种基于threading模块的Thread类。"><meta property="og:type" content="article"><meta property="og:title" content="Python多线程和Python的锁"><meta property="og:url" content="http://yoursite.com/2016/06/01/Python多线程和Python的锁.html"><meta property="og:site_name" content="技术成长的烦恼"><meta property="og:description" content="title: Python多线程和Python的锁
tags: PythonPython中实现多线程有两种方式，一种基于_thread模块(在Python2.x版本中为thread模块，没有下划线)的start_new_thread()函数，另一种基于threading模块的Thread类。"><meta property="og:updated_time" content="2016-06-01T09:02:10.062Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="Python多线程和Python的锁"><meta name="twitter:description" content="title: Python多线程和Python的锁
tags: PythonPython中实现多线程有两种方式，一种基于_thread模块(在Python2.x版本中为thread模块，没有下划线)的start_new_thread()函数，另一种基于threading模块的Thread类。"><link rel="alternate" href="/atom.xml" title="技术成长的烦恼" type="application/atom+xml"><link rel="icon" href="/favicon.png"><link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css"><link rel="stylesheet" href="/css/style.css"></head><body><div id="container"><div id="wrap"><header id="header"><div id="banner"></div><div id="header-outer" class="outer"><div id="header-title" class="inner"><h1 id="logo-wrap"><a href="/" id="logo">技术成长的烦恼</a></h1><h2 id="subtitle-wrap"><a href="/" id="subtitle">Growth Pain With Tech -- Java/Android/Python/智能家居/物联网</a></h2></div><div id="header-inner" class="inner"><nav id="main-nav"><a id="main-nav-toggle" class="nav-icon"></a> <a class="main-nav-link" href="/">Home</a> <a class="main-nav-link" href="/archives">Archives</a></nav><nav id="sub-nav"><a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a> <a id="nav-search-btn" class="nav-icon" title="Search"></a></nav><div id="search-form-wrap"><form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form></div></div></div></header><div class="outer"><section id="main"><article id="post-Python多线程和Python的锁" class="article article-type-post" itemscope itemprop="blogPost"><div class="article-meta"><a href="/2016/06/01/Python多线程和Python的锁.html" class="article-date"><time datetime="2016-06-01T08:58:00.000Z" itemprop="datePublished">2016-06-01</time></a><div class="article-category"><a class="article-category-link" href="/categories/Python/">Python</a></div></div><div class="article-inner"><header class="article-header"><h1 class="article-title" itemprop="name">Python多线程和Python的锁</h1></header><div class="article-entry" itemprop="articleBody"><p>title: Python多线程和Python的锁</p><h2 id="tags-Python"><a href="#tags-Python" class="headerlink" title="tags: Python"></a>tags: Python</h2><p>Python中实现多线程有两种方式，一种基于_thread模块(在Python2.x版本中为thread模块，没有下划线)的start_new_thread()函数，另一种基于threading模块的Thread类。<br><a id="more"></a><br>Python中实现多线程有两种方式，一种基于_thread模块(在Python2.x版本中为thread模块，没有下划线)的start_new_thread()函数，另一种基于threading模块的Thread类。<br>其实Python的多线程编程不能真正利用多核的CPU，但是用开源模块使你的计算压力分布到多核CPU上………</p><p>一.使用start_new_thread()实现线程，是比较底层的实现方式，所有线程共享他们global数据，为了达到同步，模块也提供了简单的锁机制<br>_thread.start_new_thread(function, args[, kwargs])<br>启动一个新的进程，并返回其标识符. 线程执行的函数需要的参数由args(必须为一个元组)提供，亦可通过可选参数kwargs提供关键字参数组 成的字典。当函数返回时，启动的线程也 停止退出。如果函数中存在未处理异常，会打印堆栈跟踪后线程停止退出(其他线程继续执行)。</p><p>其中线程标识符是一个非0整数，并没有直接意思，可以当作从一个线程组成的特殊字典中索引本线程的一个key，也可用_thread.get_ident()得到，在线程退出后，标识符会被系统回收。在线程执行过程中可以调用_thread.exit()终止本线程的执行。</p><p>Java代码 收藏代码<br>import _thread<br>import time<br>def threadFunction(count):<br>for i in range(count):<br>print(‘进程id为%d的打印%d’%(_thread.get_ident(),i))<br>i-=1<br>time.sleep(0.1)</p><p>def begin():<br>ident1=_thread.start_new_thread(threadFunction,(100,))<br>print(‘启动标识符为%d的进程’%(ident1,))<br>ident2=_thread.start_new_thread(threadFunction,(100,))<br>print(‘启动标识符为%d的进程’%(ident2,))</p><p>if <strong>name</strong> == ‘<strong>main</strong>‘:<br>begin()</p><p>二.使用Thread类来实现多线程，这种方式是对_thread模块(如果没有_thread,则为dummy_threading)的高级封装，在这种方式下我们需创建新类继承threading.Thread，和java一样重写threading.Thread的run方法即可.启动线程用线程的start方法，它会调用我们重写的run方法.<br>Java代码 收藏代码<br>class MyThread(threading.Thread):<br>‘’’只能重写<strong>init</strong> 和 run 两个方法’’’<br>def <strong>init</strong>(self,name):<br>threading.Thread.<strong>init</strong>(self)<br>self.name=name<br>self.bool_stop=False<br>def run(self):<br>while not self.bool_stop:<br>print(‘进程%s,于%s’%(self.name,time.asctime()))<br>time.sleep(1)<br>def stop(self):<br>self.bool_stop = True</p><p>if <strong>name</strong> == ‘<strong>main</strong>‘:<br>th1=MyThread(‘one’)<br>th2=MyThread(‘two’)<br>th1.start()<br>th2.start()</p><p>Thread类还定义了以下常用方法与属性：</p><p>Thread.getName() \Thread.setName()<br>老方式用于获取和设置线程的名称，官方建议用Thread.name替代<br>Thread.ident<br>获取线程的标识符。只有在调用start()方法执行后才有效，否则返回None。<br>Thread.is_alive()<br>判断线程是否是激活的。<br>Thread.join([timeout])<br>调用Thread.join将会使主调线程堵塞，直到被调用线程运行结束或超时。参数timeout是一个数值类型，表示超时时间，如果未提供该参数，那么主调线程将一直堵塞到被调线程结束。</p><p>Python中的锁</p><p>先用_thread模块的Lock锁来实现生产者消费者问题，Lock对象是Python提供的低级线程控制工具，使用起来非常简单，只需下面3条语句即可:<br>_thread.allocate_lock()返回一个新Lock对象，即为一个新锁<br>lock.acquire() 相当于P操作，得到一个锁，<br>lock.release()相当于V操作，释放一个锁</p><p>代码如下：<br>Java代码 收藏代码<br>import _thread,time,random<br>dish=0<br>lock = _thread.allocate_lock()<br>def producerFunction():<br>‘’’如果投的筛子比0.2大，则向盘子中增加一个苹果’’’<br>global lock,dish<br>while True:<br>if(random.random() &gt; 0.1):<br>lock.acquire()<br>if dish &lt; 100:<br>dish+=1<br>print(‘生产者增加了一个苹果，现在有%d个苹果’%(dish,))<br>lock.release()<br>time.sleep(random.random()*3)</p><p>def consumerFunction():<br>‘’’如果投的筛子比0.5大，则从盘子中取一个苹果’’’<br>global lock,dish<br>while True:<br>if(random.random() &gt; 0.9):<br>lock.acquire()<br>if dish &gt; 0:<br>dish-=1<br>print(‘消费者拿走一个苹果现，在有%d个苹果’%(dish,))<br>lock.release()<br>time.sleep(random.random()*3)</p><p>def begin():<br>ident1=_thread.start_new_thread(producerFunction,())<br>ident2=_thread.start_new_thread(consumerFunction,())<br>if <strong>name</strong> == ‘<strong>main</strong>‘:<br>begin()</p><p>另一个较高级的锁为RLock锁，RLock对象内部维护着一个Lock对象，它是一种可重入的对象。对于Lock对象而言，如果一个线程连续两次进行acquire操作，那么由于第一次acquire之后没有release，第二次acquire将挂起线程。这会导致Lock对象永远不会release，使得线程死锁。RLock对象允许一个线程多次对其进行acquire操作，因为在其内部通过一个counter变量维护着线程acquire的次数。而且每一次的acquire操作必须有一个release操作与之对应，在所有的release操作完成之后，别的线程才能申请该RLock对象。</p><p>threading模块对Lock也提供和封装，提供了更高级的同步方式（可以理解为更高级的锁），包括threading.Event和threading.Condition，其中threading.Event为提供了简单的同步方式：一个进程标记event，其他进程等待，只需下面的几个方法即可：<br>Event.wait([timeout])<br>堵塞线程，直到Event对象内部标识位被设为True或超时（如果提供了参数timeout）。<br>Event.set()<br>将标识号设为Ture<br>Event.clear()<br>设为标识符False</p><p>threading.Condition　可以把Condiftion理解为一把高级的琐，它提供了比Lock, RLock更高级的功能，允许我们能够控制复杂的线程同步问题。threadiong.Condition在内部维护一个琐对象（默认是RLock），可以在创建Condigtion对象的时候把琐对象作为参数传入。Condition也提供了acquire, release方法，其含义与琐的acquire, release方法一致，其实它只是简单的调用内部琐对象的对应的方法而已。Condition还提供了如下方法(特别要注意：这些方法只有在占用琐(acquire)之后才能调用，否则将会报RuntimeError异常。)：<br>Condition.wait([timeout]):<br>wait方法释放内部所占用的琐，同时线程被挂起，直至接收到通知被唤醒或超时（如果提供了timeout参数的话）。当线程被唤醒并重新占有琐的时候，程序才会继续执行下去。<br>Condition.notify():<br>唤醒一个挂起的线程（如果存在挂起的线程）。注意：notify()方法不会释放所占用的琐。<br>Condition.notify_all()<br>唤醒所有挂起的线程（如果存在挂起的线程）。注意：这些方法不会释放所占用的琐。</p></div><footer class="article-footer"><a data-url="http://yoursite.com/2016/06/01/Python多线程和Python的锁.html" data-id="ciowozftz0005f8hb58bhtkb1" class="article-share-link">Share</a><ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Python/">Python</a></li></ul></footer></div><nav id="article-nav"><a href="/2016/06/01/Strace-跟踪进程中的系统调用.html" id="article-nav-newer" class="article-nav-link-wrap"><strong class="article-nav-caption">Newer</strong><div class="article-nav-title">Strace 跟踪进程中的系统调用</div></a> <a href="/2016/06/01/智能家居领域十大短距离无线通信技术.html" id="article-nav-older" class="article-nav-link-wrap"><strong class="article-nav-caption">Older</strong><div class="article-nav-title">智能家居领域十大短距离无线通信技术</div></a></nav></article></section><aside id="sidebar"><div class="widget-wrap"><h3 class="widget-title">Categories</h3><div class="widget"><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Python/">Python</a></li></ul></div></div><div class="widget-wrap"><h3 class="widget-title">Tags</h3><div class="widget"><ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python/">Python</a></li></ul></div></div><div class="widget-wrap"><h3 class="widget-title">Tag Cloud</h3><div class="widget tagcloud"><a href="/tags/Linux/" style="font-size: 10px">Linux</a> <a href="/tags/Python/" style="font-size: 10px">Python</a></div></div><div class="widget-wrap"><h3 class="widget-title">Archives</h3><div class="widget"><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/06/">June 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/">May 2016</a></li></ul></div></div><div class="widget-wrap"><h3 class="widget-title">Recent Posts</h3><div class="widget"><ul><li><a href="/2016/06/01/Strace-跟踪进程中的系统调用.html">Strace 跟踪进程中的系统调用</a></li><li><a href="/2016/06/01/Python多线程和Python的锁.html">Python多线程和Python的锁</a></li><li><a href="/2016/06/01/智能家居领域十大短距离无线通信技术.html">智能家居领域十大短距离无线通信技术</a></li><li><a href="/2016/05/31/hello-world.html">正式开博客</a></li></ul></div></div></aside></div><footer id="footer"><div class="outer"><div id="footer-info" class="inner">&copy; 2016 Javy Lee<br>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a></div></div></footer></div><nav id="mobile-nav"><a href="/" class="mobile-nav-link">Home</a> <a href="/archives" class="mobile-nav-link">Archives</a></nav><script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script><link rel="stylesheet" href="/fancybox/jquery.fancybox.css"><script src="/fancybox/jquery.fancybox.pack.js"></script><script src="/js/script.js"></script></div></body></html>